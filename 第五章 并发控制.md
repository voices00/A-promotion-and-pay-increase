##  第五章 并发控制

GO提供了三种并发控制的手段，分别是：

- Channel: 使用channel控制子协程
- WaitGroup : 使用信号量机制控制子协程
- Context: 使用上下文控制子协程

### 5.1 Channel 

> ​	channel一般用于协程之间的通信，也可以用于并发控制。
>
> ​	 使用channel来控制子协程的优点是实现简单，缺点是当需要大量创建协程时就需要有相同数量的channel，而且对于子协程继续派生出来的协程不方便控制。 

### 5.2 `WaitGroup`

​	`WaitGroup`是go应用开发过程中经常使用的并发控制技术。

#### 信号量

> ​	信号量是Unix系统提供的一种保护共享资源的机制，用于防止多个线程同时访问某个资源。
>
> 可简单理解为信号量为一个数值：
>
> - 当信号量>0时，表示资源可用，获取信号量时系统自动将信号量减1；
>
> - 当信号量==0时，表示资源暂不可用，获取信号量时，当前线程会进入睡眠，当信号量为正时被唤醒；
>
>   `WaitGroup`实现中也使用了信号量

#### `WaitGroup`数据结构

```go
type WaitGroup struct {
    state1 [3]uint32
}
```

state1是个长度为3的数组，其中包含了state和一个信号量，而state实际上是两个计数器：

- counter： 当前还未执行结束的goroutine计数器
- waiter count: 等待goroutine-group结束的goroutine数量，即有多少个等候者
- semaphore: 信号量

`WaitGroup`对外提供三个接口：

- Add(delta int): 将delta值加到counter中
- Wait()： waiter递增1，并阻塞等待信号量semaphore
- Done()： counter递减1，按照waiter数值释放相应次数信号量

> Add(dalta int)
>
> ​	 Add()做了两件事，一是把delta值累加到counter中，因为delta可以为负值，也就是说counter有可能变成0或负值，所以第二件事就是当counter值变为0时，根据waiter数值释放等量的信号量，把等待的goroutine全部唤醒，如果counter变为负值，则panic. 
>
> Wait()
>
> ​	 Wait()方法也做了两件事，一是累加waiter, 二是阻塞等待信号量 
>
> Done()
>
> ​	 Done()只做一件事，把counter减1，Add()可以接受负值，所以Done实际上只是调用了Add(-1)。 

Tips:

​	Add()操作必须早于Wait(),否则会触发panic。

​	Add()设置的值必须与实际等待的goroutine个数一致，否则也会触发panic。

### 5.3 Context

​	`Golang context`是`Golang`应用开发常用的并发控制技术，它与`WaitGroup`最大的不同点是`context`对于派生goroutine有更强的控制力，它可以控制多级的goroutine。context翻译成中文是”上下文”，即它可以控制一组呈树状结构的goroutine，每个goroutine拥有相同的上下文。

#### 实现原理

> ​	 context实际上只定义了接口，凡是实现该接口的类都可称为是一种context，官方包中实现了几个常用的context，分别可用于不同的场景。 

```go
type Context interface {
    Deadline() (deadline time.Time, ok bool)

    Done() <-chan struct{}

    Err() error

    Value(key interface{}) interface{}
}
```

 基础的context接口只定义了4个方法 

>  Deadline()
>
> ​	该方法返回一个deadline和标识是否已设置deadline的bool值，如果没有设置deadline，则ok == false，此时deadline为一个初始值的time.Time值
>
> Done()
>
> ​	该方法返回一个channel，需要在select-case语句中使用，如”case <-context.Done():”。当context关闭后，Done()返回一个被关闭的管道，关闭的管道仍然是可读的，据此goroutine可以收到关闭请求；
> 当context还未关闭时，Done()返回nil。
>
> Err()
>
> ​	该方法描述context关闭的原因。关闭原因由context实现控制，不需要用户设置。比如Deadline context，关闭原因可能是因为deadline，也可能提前被主动关闭，那么关闭原因就会不同:
>
> - 因deadline关闭：“context deadline exceeded”；
> - 因主动关闭： “context canceled”。
>
> 当context关闭后，Err()返回context的关闭原因；
> 当context还未关闭时，Err()返回nil；
>
> Value()
>
> ​	有一种context，它不是用于控制呈树状分布的goroutine，而是用于在树状分布的goroutine间传递信息。Value()方法就是用于此种类型的context，该方法根据key值查询map中的value。

空Context

​	 context包中定义了一个空的context， 名为emptyCtx，用于context的根节点，空的context只是简单的实现了Context，本身不包含任何值，仅用于其他context的父节点 

​	 context包中定义了一个公用的emptCtx全局变量，名为background，可以使用context.Background()获取它 

context包提供了4个方法创建不同类型的context，使用这四个方法时如果没有父context，都需要传入backgroud，即backgroud作为其父节点：

- WithCancel()
- WithDeadline()
- WithTimeout()
- WithValue()

​	context包中实现Context接口的struct，除了emptyCtx外，还有cancelCtx、timerCtx和valueCtx三种，正是基于这三种context实例，实现了上述4种类型的context。