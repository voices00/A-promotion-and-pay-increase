## 第四章 内存管理

### 4.1 内存分配

#### 基础概念

> ​	为了方便自主管理内存，一般做法是先向系统申请一块内存，然后切割成小块，通过一定的内存分配算法管理内存。
>
> ​	 `Golang`程序启动时会向系统申请内存 ，预申请的内存划分为spans、bitmap、arena三部分。其中arena即为所谓的堆区，应用中需要的内存从这里分配。其中spans和bitmap是为了管理arena区而存在的。
>
> ​	arena的大小为512G，为了方便管理把arena区域划分成一个个的page，每个page为8KB,一共有512GB/8KB个页；
>
> ​	spans区域存放span的指针，每个指针对应一个或多个page，所以span区域的大小为(512GB/8KB)*指针大小8byte = 512M
>
> ​	bitmap区域大小也是通过arena计算出来，不过主要用于GC。

#### `span`

>  	span是用于管理arena页的关键数据结构，每个span中包含1个或多个连续页，为了满足小对象分配，span中的一页会划分更小的粒度，而对于大对象比如超过页大小，则通过多页实现。 

#### `class`

>  	根据对象大小，划分了一系列class，每个class都代表一个固定大小的对象，以及每个span的大小。 
>
> - class： class ID，每个span结构中都有一个class ID, 表示该span可处理的对象类型
>
> - bytes/obj：该class代表对象的字节数
>
> - bytes/span：每个span占用堆的字节数，也即页数*页大小
>
> - objects: 每个span可分配的对象个数，也即（bytes/spans）/（bytes/obj）
>
> - waste bytes: 每个span产生的内存碎片，也即（bytes/spans）%（bytes/obj）
>
>   超过32K大小的由特殊的class表示，该class ID为0，每个`class`只包含一个对象。

#### 内存分配过程

>  针对待分配对象的大小不同有不同的分配逻辑： 
>
> - (0, 16B) 且不包含指针的对象： Tiny分配
> - (0, 16B) 包含指针的对象：正常分配
> - [16B, 32KB] : 正常分配
> - (32KB, -) : 大对象分配
>   其中Tiny分配和大对象分配都属于内存管理的优化范畴，这里暂时仅关注一般的分配方法。
>
> 以申请size为n的内存为例，分配步骤如下：
>
> 1. 获取当前线程的私有缓存mcache
> 2. 根据size计算出适合的class的ID
> 3. 从mcache的alloc[class]链表中查询可用的span
> 4. 如果mcache没有可用的span则从mcentral申请一个新的span加入mcache中
> 5. 如果mcentral中也没有可用的span则从mheap中申请一个新的span加入mcentral
> 6. 从该span中获取到空闲对象地址并返回

#### 小结

> 1. Golang程序启动时申请一大块内存，并划分成spans、bitmap、arena区域
> 2. arena区域按页划分成一个个小块
> 3. span管理一个或多个页
> 4. mcentral管理多个span供线程申请使用
> 5. mcache作为线程私有资源，资源来源于mcentral

### 4.2 垃圾回收

​	垃圾就是不再需要的内存块，如果不清理就没办法再次被分配使用

#### 垃圾回收算法

> 业界常见的垃圾回收算法有以下几种：
>
> ​	引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0时回收该对象。
>
> - 优点：对象可以很快地被回收，不会出现内存耗尽或达到某个阀值时才回收。
> - 缺点：不能很好地处理循环引用，而且实时维护引用计数，也有一定的代价。
> - 代表语言：Python、PHP、Swift
>
> ​	标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收。
>
> - 优点：解决了引用计数的缺点。
> - 缺点：需要STW，即要暂时停掉程序运行。
> - 代表语言：Golang（其采用三色标记法）
>
>  	分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不同的回收算法和回收频率。
>
> - 优点：回收性能好
> - 缺点：算法复杂
> - 代表语言： JAVA

#### go垃圾回收

> ​	简单来说，垃圾回收的核心就是标记出哪些内存还在使用中，哪些内存不再使用了，把未被引用的内存回收，以供后续内存分配使用
>
> ​	 垃圾回收开始时从root对象开始扫描，把root对象引用的内存标记为”被引用”，考虑到内存块中存放的可能是指针，所以还需要递归的进行标记，全部标记完成后，只保留被标记的内存，未被标记的全部标识为未分配即完成了回收。 
>
> ​	三色标记法：三色只是为了叙述上方便抽象出来的一种说法，实际上对象并没有颜色之分。这里的三色，对应了垃圾回收过程中对象的三种状态：
>
> - 灰色：对象还在标记队列中等待
> - 黑色：对象已被标记，gcmarkBits对应的位为1（该对象不会在本次GC中被清理）
> - 白色：对象未被标记，gcmarkBits对应的位为0（该对象将会在本次GC中被清理）
>
> ​	`Stop The World`：对于垃圾回收来说，回收过程中也需要控制住内存的变化，否则回收过程中指针传递会引起内存引用关系变化，如果错误的回收了还在使用的内存，结果将是灾难性的。
>
> ​	Golang中的STW（Stop The World）就是停掉所有的goroutine，专心做垃圾回收，待垃圾回收结束后再恢复goroutine。
>
> ​	STW时间的长短直接影响了应用的执行，时间过长对于一些web应用来说是不可接受的，这也是广受诟病的原因之一。
>
> ​	为了缩短STW的时间，Golang不断优化垃圾回收算法

#### 垃圾回收优化

> ​	写屏障：写屏障就是让goroutine与GC同时运行的手段。虽然写屏障不能完全消除STW，但是可以大大减少STW的时间。写屏障类似一种开关，在GC的特定时机开启，开启后指针传递时会把指针标记，即本轮不回收，下次GC时再确定。GC过程中新分配的内存会被立即标记，用的就是写屏障技术，也即GC过程中分配的内存不会在本轮GC中回收。
>
> ​	辅助GC： 为了防止内存分配过快，在GC执行过程中，如果goroutine需要分配内存，那么这个goroutine会参与一部分GC的工作，即帮助GC做一部分工作，这个机制叫作Mutator Assist。 

#### 垃圾回收触发时机

> ​	内存分配量达到阀值触发GC：每次内存分配时都会检查当前内存分配量是否已达到阀值，如果达到阀值则立即启动GC。
>
> ```
> 阀值 = 上次GC内存分配量 * 内存增长率
> ```
>
> 内存增长率由环境变量`GOGC`控制，默认为100，即每当内存扩大一倍时启动GC。
>
> ​	定期触发GC：默认情况下，最长2分钟触发一次GC.
>
> ​	手动触发：程序代码中也可以使用`runtime.GC()`来手动触发GC。这主要用于GC性能测试和统计。

###  4.3 逃逸分析

​	逃逸分析是指由编译器决定内存分配的位置，不需要程序员指定。在函数中申请一个新的对象：

- 如果分配在栈中，则函数执行结束可自动将内存回收；
- 如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理；

有了逃逸分析，返回函数局部变量将变得可能，除此之外，逃逸分析还跟闭包息息相关，了解哪些场景下对象会逃逸至关重要。

#### 逃逸策略

> 每当函数中申请新的对象，编译器会根据该对象是否被函数外部引用来决定是否逃逸：
>
> 1. 如果函数外部没有引用，则优先放到栈中；
> 2. 如果函数外部存在引用，则必定放到堆中；
>
> 注意，对于函数外部没有引用的对象，也有可能放到堆中，比如内存过大超过栈的存储能力。

#### 逃逸场景

> ​	指针逃逸： Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例 
>
> ​	栈空间不足逃逸： 当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。 
>
> ​	动态类型逃逸： 很多函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也会产生逃逸。 
>
> ​	闭包引用对象逃逸：某著名的开源框架实现了某个返回Fibonacci数列的函数：
>
> ```go
> func Fibonacci() func() int {
>     a, b := 0, 1
>     return func() int {
>         a, b = b, a+b
>         return a
>     }
> }
> ```
>
> ​	 该函数返回一个闭包，闭包引用了函数的局部变量a和b，使用时通过该函数获取该闭包，然后每次执行闭包都会依次输出Fibonacci数列。  Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸 。

#### 逃逸小结

> 栈上分配内存比在堆中分配内存有更高的效率
>
> 栈上分配的内存不需要GC处理
>
> 堆上分配的内存使用完毕会交给GC处理
>
> 逃逸分析目的是决定内分配地址是栈还是堆
>
> 逃逸分析在编译阶段完成