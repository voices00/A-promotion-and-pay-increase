##  第三章 协程

### 3.1 概念

#### 进程

> ​	进程是应用程序的启动示例，每个进程都拥有独立的内存空间，不同进程通过进程间的通信方式来通信

#### 线程

> ​	线程从属于进程，每个进程至少包含一个线程，线程是` cpu`调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信

#### 协程

> ​	协程可理解为一种轻量级线程，与线程相比，协程不受操作系统调度，协程调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行。Go应用程序的协程调度器由runtime包提供，用户使用go关键字即可创建协程，这就是在语言层面直接支持协程的含义。

#### 协程优势

> ​	在高并发应用中频繁创建线程会造成不必要的开销，所以就有了线程池技术，可以有效地减少线程的创建和销毁带来的开销。过多的线程会导致上下文切换开销变大，而工作在用户态的协程可以大大减少上下文切换的开销。

### 3.2 调度模型

#### 线程模型

​	线程可分为用户线程和内核线程，用户线程由用户创建、同步和销毁，内核线程则由内核来管理。根据用户线程管理方式的不同，分为三种线程模型。

> ​	N:1模型，即N个用户线程运行在一个内核线程中。优点是用户线程上下文切换快，缺点是无法充分利用`cpu`多核的算力。
>
> ​	1:1模型，即每个用户线程对应一个内核线程，优点是充分利用了`cpu`的算力，缺点是线程上下文切换较慢。
>
> ​	M:N模型，M个用户线程（协程）运行在N个内核线程中，优点是充分利用`cpu`多核的算力且协程上下文切换快，缺点是该模型的调度算法较复杂。

#### Go调度器模型

​	包含三个关键实体，machine（M）、Processor（P）和goroutine（G）。

> ​	M：工作线程，由操作系统调度
>
> ​	P：处理器（go定义的概念，不是`cpu`），包含运行Go代码运行的必要资源，也有调度goroutine的能力
>
> ​	G：Go协程，每个go关键字都会创建一个协程

​	M必须持有P才可以执行代码，M跟系统其他线程一样会被系统调用阻塞。P的个数在程序启动时决定，默认情况下等同于CPU核数。

​	M的个数通常稍大于P的个数，因为除了运行Go代码，routine包还有其他内置任务需要处理。

### 3.3 调度策略

#### 队列轮转

> ​	每个处理器P维护着一个协程G的队列，处理器P依次将协程G调度到M中执行。
>
> ​	协程G执行结束后，处理器P会再次调度一个协程G到M中执行。
>
> ​	同时，每个P会周期性地查看全局队列中是否有G待运行并将其调度到M中执行，全局队列中的G主要来自从系统调用中恢复的G。之所以P会周期性地查看全局队列，也是为了防止全局队列中的G长时间得不到调度机会而饿死。

#### 系统调用

> ​	P的个数默认等于CPU核数，每个M必须持有一个P才可以执行G，一般情况下M的个数会略大于P的个数，这多出来的M将会在G产生系统调用时发挥作用。类似线程池，Go也提供一个M的池子，需要时从池子中获取，用完放回池子，不够用时就再创建一个。
>
> ​	当M运行的某个G产生系统调用：G0即将进入系统调用时，M0将释放P，进而某个空闲的M1获取P，继续执行P队列中剩下的G。而M0由于陷入系统调用而进被阻塞，M1接替M0的工作，只要P不空闲，就可以保证充分利用CPU。
>
> M1的来源有可能是M的缓存池，也可能是新建的。当G0系统调用结束后，根据M0是否能获取到P，将会将G0做不同的处理：
>
> 1. 如果有空闲的P，则获取一个P，继续执行G0。
> 2. 如果没有空闲的P，则将G0放入全局队列，等待被其他的P调度。然后M0将进入缓存池睡眠。

#### 工作量窃取

> ​	当某个处理器P没有需要调度的协程时，将从其他处理器中偷取协程：处理器P在没有协程需要调度时会查询全局队列，如果全局队列也没有协程需要调度，则会从另一个正在运行的处理器P中偷取协程，每次偷取一半。

#### 抢占式调度

> ​	指避免某个协程长时间执行，而阻碍其他协程被调度的机制。
>
> ​	调度器会监控每个协程的执行时间，一旦执行时间过长且有其他协程在等待时，会把协程暂停，转而调度等待的协程，以达到类似时间片轮转的效果。

#### GOMAXPROCS设置对性能的影响

> ​	一般，程序运行时就将GOMAXPROCS大小设置为CPU核数，可让Go程序充分利用CPU。但在某些IO密集型的应用里，这个值可能并不意味着性能最好。理论上当某个Goroutine进入系统调用时，会有一个新的M被启用或创建，继续占满CPU。但由于Go调度器检测到M被阻塞是有一定延迟的，也即旧的M被阻塞和新的M得到运行之间是有一定间隔的，所以在IO密集型应用中不妨把GOMAXPROCS设置的大一些，或许会有好的效果。

